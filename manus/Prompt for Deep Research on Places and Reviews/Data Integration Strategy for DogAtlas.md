# Data Integration Strategy for DogAtlas

This document outlines a strategy for integrating the `places.jsonl` and `reviews.jsonl` data generated by Manus into the DogAtlas application, based on the provided Prisma schema (`schema.prisma`).

## 1. Overview of Data Models

### Prisma Schema Models

Based on `dogatlas/prisma/schema.prisma`, the key models relevant for data ingestion are:

*   **`Place`**: Represents a location with attributes like `city`, `name`, `category`, `address`, `lat`, `lng`, `website`, `phone`, `rating`, `ratingCount`, etc.
*   **`PlaceFeature`**: A related model for `Place` to store key-value pairs of features (e.g., `dogs_allowed_indoors`, `water_bowls`).
*   **`PlaceHour`**: A related model for `Place` to store opening and closing hours for each day.
*   **`Photo`**: Stores URLs and metadata for photos associated with a `Place`.
*   **`Review`**: Represents a user review with `rating`, `body` (for excerpt/summary), `tags`, and a relation to `Place`.
*   **`Activity`**: A related model for `Place` to store specific activity details (e.g., for lakes or trails).

### Manus JSONL Schemas

The Manus-generated data will conform to the following schemas:

**`places.jsonl`**

```json
{
  "city": "Berlin",
  "name": "Café Hundeglück",
  "category": "cafe_restaurant_bar",
  "description": "Dog-friendly café with outdoor seating and water bowls.",
  "address": "Mainstr. 12, 10967 Berlin",
  "district": "Neukölln",
  "neighborhood": "Kreuzberg",
  "lat": 52.4901,
  "lng": 13.4123,
  "website": "https://cafehundeglueck.de",
  "phone": "+49 30 1234567",
  "priceLevel": 2,
  "status": "published",
  "features": {
    "dogs_allowed_indoors": "true",
    "off_leash_allowed": "No",
    "water_bowls": "true",
    "fenced": "false",
    "shade": "true",
    "poop_bags": "UNKNOWN"
  },
  "hours": [
    { "day": 1, "open": "08:00", "close": "20:00" } // optional, 0=Sun..6=Sat
  ],
  "activity": {
    "type": "lake" | "trail_hike",
    "attrs": { "entry": "beach", "shallow_entry": true, "algae_flag": "UNKNOWN" }
  } || null,
  "rating": 4.6,
  "ratingCount": 87,
  "photos": [
    { "url": "https://...", "width": 1600, "height": 900, "source": "google_places" }
  ],
  "external_ids": {
    "google_place_id": "ChIJ123abc",
    "osm_id": null,
    "facebook_url": null,
    "instagram_url": null
  }
}
```

**`reviews.jsonl`**

```json
{
  "google_place_id": "ChIJ123abc",      // or fallback: composite key below
  "fallback_key": {
    "name": "Café Beispiel",
    "address": "Street 1, Berlin"
  },
  "source": "google|reddit|tripadvisor|official_site|forum",
  "url": "https://…",                 // direct link to review or listing
  "language": "de",
  "published_at": "2024-08-01T10:00:00Z",
  "rating": 5,
  "excerpt": "The staff gave our dog water and treats!", // <= 280 chars, or paraphrase
  "summary": "Very dog-friendly indoors, staff offers water bowls and snacks.",
  "tags": ["dogs_indoor", "water_bowls", "friendly_staff"],
  "author": "First L.",              // if public; else "Anonymous"
  "helpful_count": 2
}
```

## 2. Mapping Strategy

### `places.jsonl` to `Place` Model

Most fields in `places.jsonl` directly map to the `Place` model in `schema.prisma`:

*   `city` -> `Place.city`
*   `name` -> `Place.name`
*   `category` -> `Place.category`
*   `description` -> `Place.description`
*   `address` -> `Place.address`
*   `district` -> `Place.district`
*   `neighborhood` -> `Place.neighborhood`
*   `lat` -> `Place.lat`
*   `lng` -> `Place.lng`
*   `website` -> `Place.website`
*   `phone` -> `Place.phone`
*   `priceLevel` -> `Place.priceLevel`
*   `rating` -> `Place.rating`
*   `ratingCount` -> `Place.ratingCount`
*   `status` -> `Place.status` (defaulting to "published" as per prompt)

**Derived Fields:**

*   `slug`: The `Place` model has a `slug` field. This will need to be generated from the `name` field during ingestion (e.g., by lowercasing and replacing spaces with hyphens). This is crucial for unique identification and URL generation.

**Related Models:**

*   **`features` (JSON object) -> `PlaceFeature` (related model):** The `features` object in `places.jsonl` needs to be transformed into multiple `PlaceFeature` records, each with a `key` and `value`. For example, `"dogs_allowed_indoors": "true"` would become a `PlaceFeature` record with `key: "dogs_allowed_indoors"` and `value: "true"`. For improved normalization, `"true"` can be mapped to boolean `true`, `"false"` to boolean `false`, and `"UNKNOWN"` to `null` in the database, allowing for stronger filtering.
*   **`hours` (array of objects) -> `PlaceHour` (related model):** Each object in the `hours` array will map directly to a `PlaceHour` record, linking back to the `Place`.
*   **`activity` (JSON object) -> `Activity` (related model):** The `activity` object will map to an `Activity` record, with `type` and `attrs` (which is a `Json` type in Prisma, allowing direct storage of the nested object).
*   **`photos` (array of objects) -> `Photo` (related model):** Each object in the `photos` array will map to a `Photo` record, storing the `url`, `width`, `height`, and `source`. For performance, the original URL will be stored, and an image proxy/resizer (e.g., `next/image`) will be used for transformations. Optional fields for `blurhash` or LQIP (Low Quality Image Placeholder) can be added to the `Photo` model for smooth lazy-loading.

**External IDs:**

*   `external_ids` (JSON object): This object contains `google_place_id`, `osm_id`, `facebook_url`, and `instagram_url`. These can be stored as a JSON field in the `Place` model if a `Json` type field is added, or specific fields can be added to the `Place` model for each external ID. Given the current `schema.prisma`, it might be best to add specific fields for `googlePlaceId` and `osmId` to the `Place` model for easier querying and indexing, and potentially a `Json` field for other less critical external URLs. Alternatively, these could be stored as `PlaceFeature` records if a flexible schema is preferred, though direct fields are better for primary identifiers. For now, we will assume `google_place_id` will be a direct field on `Place` for efficient lookups, and others can be added as needed. *Self-correction: The current `Place` model does not have explicit fields for `google_place_id` or `osm_id`. It would be beneficial to add these to the `Place` model in `schema.prisma` for direct mapping and efficient querying. For the purpose of this strategy, we will assume these will be added or handled via `Submission` payload if direct fields are not desired.* Given the prompt explicitly mentions `google_place_id` for deduplication and deep-linking, adding it as a direct field to the `Place` model is highly recommended.

### `reviews.jsonl` to `Review` Model

*   `rating` -> `Review.rating`
*   `excerpt` -> `Review.body` (This field in Prisma is `String?`, so it can store the excerpt or summary). The `body` field will store the short excerpt (<=280 chars). For power users or future use, the full review text (if available) can be stored in a `metadata Json` field.
*   `tags` -> `Review.tags` (Prisma supports `String[]` for array of strings). Tag standardization should be considered, potentially using a controlled vocabulary or enum-like system to avoid messy filtering.
*   `source`, `url`, `language`, `published_at`, `author`, `helpful_count`: These fields are present in `reviews.jsonl` but not directly in the `Review` model. They could be stored as a `Json` field (e.g., `metadata`) in the `Review` model, or specific fields could be added to the `Review` model for each. Given the importance of `source` and `url` for legal compliance and traceability, adding them as direct fields to the `Review` model is recommended. `published_at` can map to `createdAt` or a new `publishedAt` field. `author` and `helpful_count` could be part of a `metadata` JSON field.

**Linking Reviews to Places:**

*   `google_place_id`: This will be the primary key for linking reviews to places. During ingestion, the `google_place_id` from `reviews.jsonl` will be used to find the corresponding `Place` record in the database, and its `id` will be used to populate `Review.placeId`. For resilience, a composite unique key on `(city, slug)` will be used as a backup linking mechanism if `google_place_id` is unavailable or changes. Unmatched reviews will be logged into a "holding" table for later review.
*   `fallback_key`: If `google_place_id` is not available, the `fallback_key` (name + address) can be used to attempt to match a `Place`.

## 3. Ingestion Process

The ingestion process will involve two main steps, corresponding to the `places.jsonl` and `reviews.jsonl` files.

### Step 1: Ingesting `places.jsonl`

This step will involve reading each line from `places.jsonl` and creating/updating `Place` records along with their related `PlaceFeature`, `PlaceHour`, `Activity`, and `Photo` records.

**Proposed Script (`scripts/import_places.ts` or similar):**

1.  **Read `places.jsonl`:** Read the file line by line.
2.  **Parse JSON:** Parse each line into a JavaScript object.
3.  **Hashing for Deduplication/Updates:** Calculate a hash (e.g., `md5(JSON.stringify(obj))`) for incoming records. If the hash matches an existing record, skip the write to reduce database churn.
4.  **Generate `slug`:** Create a unique `slug` from the `name` field.
5.  **Upsert `Place`:** Use Prisma's `upsert` functionality to either create a new `Place` record or update an existing one based on a unique identifier (e.g., `city` and `slug`, or `google_place_id` if added to `Place` model). This will handle deduplication.
6.  **Create/Connect `PlaceFeature`:** For each entry in the `features` object, create a `PlaceFeature` record and connect it to the newly created or updated `Place`. Normalize values to boolean or null as discussed.
7.  **Create/Connect `PlaceHour`:** For each entry in the `hours` array, create a `PlaceHour` record and connect it to the `Place`.
8.  **Create/Connect `Activity`:** If an `activity` object exists, create an `Activity` record and connect it to the `Place`.
9.  **Create/Connect `Photo`:** For each entry in the `photos` array, create a `Photo` record and connect it to the `Place`. Implement image proxy/resizer logic.
10. **Handle `external_ids`:** Store `google_place_id` and `osm_id` if direct fields are added to `Place`. Other external IDs can be stored in a `Json` field or as `PlaceFeature` records.

### Step 2: Ingesting `reviews.jsonl`

This step will involve reading each line from `reviews.jsonl` and creating `Review` records, linking them to existing `Place` records.

**Proposed Script (`scripts/import_reviews.ts`):**

1.  **Read `reviews.jsonl`:** Read the file line by line.
2.  **Parse JSON:** Parse each line into a JavaScript object.
3.  **Find `Place`:**
    *   First, attempt to find the `Place` using `google_place_id`.
    *   If not found, use the `fallback_key` (name and address) to search for a matching `Place`.
    *   If a `Place` cannot be found, the review should be logged as unmatchable (e.g., into a "holding" table) or temporarily stored for manual review.
4.  **Create `Review`:** Once the `Place` is identified, create a new `Review` record, populating `rating`, `body` (from `excerpt`), `tags`, and `placeId`.
5.  **Handle additional review fields:** Store `source`, `url`, `language`, `published_at`, `author`, `helpful_count` either as direct fields (if added to `Review` model) or within a `Json` metadata field (for full review text and other less critical data).

## 4. Recommendations for Schema Adjustments

To optimize the integration and leverage the data effectively, the following adjustments to `schema.prisma` are recommended:

*   **`Place` Model:**
    *   Add `googlePlaceId String? @unique` to the `Place` model. This is crucial for efficient deduplication and linking with Google-sourced reviews.
    *   Consider adding `osmId String? @unique` to the `Place` model for OpenStreetMap integration.
    *   Consider adding an `externalUrls Json?` field to `Place` to store `facebook_url` and `instagram_url` from `external_ids`.
    *   Update `rating` to `Float? @default(0)` and `ratingCount` to `Int? @default(0)` to provide default values.
*   **`Review` Model:**
    *   Add `source String?` to the `Review` model.
    *   Add `url String?` to the `Review` model.
    *   Add `language String?` to the `Review` model.
    *   Add `publishedAt DateTime?` to the `Review` model (or use `createdAt` if it aligns with the `published_at` from the JSONL).
    *   Add `author String?` and `helpfulCount Int? @default(0)` to the `Review` model.
    *   Add a `metadata Json?` field to store the full review text and other less critical review-specific data.

These schema adjustments will allow for a more direct and robust mapping of the Manus-generated data, reducing the need for complex transformations during ingestion and improving data accessibility within the application.

## 5. Automation

To keep DogAtlas data fresh, the ingestion process should be automated:

*   **CLI Commands:** Wrap the ingestion logic into CLI commands (e.g., `pnpm ingest:places` and `pnpm ingest:reviews`).
*   **Cron Jobs:** Implement cron jobs (e.g., using GitHub Actions, Vercel cron, or a local runner) to periodically re-run the ingestion process.

## 6. Extra Brainstorm & Considerations

*   **User-Generated Reviews:** If user-submitted reviews are to be merged with Manus data, flag them with a `source = "dogatlas_user"` to distinguish them.
*   **Scoring System:** Instead of displaying raw Google stars, consider implementing a custom DogAtlas Score, weighted by factors like freshness, tags, and sentiment analysis, to provide a more tailored rating.
*   **Tag Standardization:** Develop a controlled vocabulary or enum-like system for `tags` to ensure consistency and enable cleaner filtering.
*   **Legal Compliance:** Always retain the `url` to the original review source. This protects against potential complaints regarding republishing content.

## 7. Next Steps

1.  **Confirm Schema Adjustments:** Review the proposed schema adjustments with the development team.
2.  **Develop Importer Scripts:** Proceed with developing the `import_places.ts` and `import_reviews.ts` scripts based on this strategy.
3.  **Testing:** Thoroughly test the importer scripts with sample data generated by Manus to ensure correct data ingestion and relationships.

This strategy provides a clear path for integrating the rich data collected by Manus into the DogAtlas platform, enabling the application to leverage comprehensive place and review information effectively.

